// package cmd

// /*
// go run main.go configure \
//   -u "test@gmail.com" \
//   -n "Test User" \
//   -p "Test@1234" \
//   -c "Test@1234"
// */
// import (
// 	"bytes"
// 	"encoding/json"
// 	"fmt"
// 	"io"
// 	"net/http"
// 	"strings"

// 	"github.com/AlecAivazis/survey/v2"
// 	"github.com/aritradeveops/porichoy/porichoyctl/utils"
// 	"github.com/spf13/cobra"
// )

// type RootUser struct {
// 	Email           string `json:"email,omitempty"`
// 	Name            string `json:"name,omitempty"`
// 	Password        string `json:"password,omitempty"`
// 	ConfirmPassword string `json:"confirm_password,omitempty"`
// }

// type RootApp struct {
// 	Name string `json:"name" validate:"required,min=3"`
// 	// TODO: think about this field
// 	Domain               string   `json:"domain" validate:"required"`
// 	LandingUrl           string   `json:"landing_url" validate:"required,url"`
// 	Logo                 string   `json:"logo,omitempty" validate:"omitempty,url"`
// 	RedirectUris         []string `json:"redirect_uris" validate:"required,min=1,dive,url"`
// 	SuccessCallbackUrl   string   `json:"success_callback_url" validate:"required,url"`
// 	ErrorCallbackUrl     string   `json:"error_callback_url" validate:"required,url"`
// 	JwtAlgo              string   `json:"jwt_algo" validate:"required,jwt_algo"`
// 	JwtSecretResolveFrom string   `json:"jwt_secret_resolve_from" validate:"oneof=env db literal"`
// 	JwtSecretResolver    string   `json:"jwt_secret_resolver" validate:"required,resolver"`
// 	JwtLifetime          string   `json:"jwt_lifetime" validate:"required,duration"`
// 	RefreshTokenLifetime string   `json:"refresh_token_lifetime" validate:"required,duration"`
// }

// // var rootUser RootUser
// // var rootApp RootApp

// func init() {
// 	// configureCmd.Flags().StringVarP(&rootUser.Email, "username", "u", "", "username (email) of the root user.")
// 	// configureCmd.Flags().StringVarP(&rootUser.Name, "name", "n", "", "name of the root user.")
// 	// configureCmd.Flags().StringVarP(&rootUser.Password, "password", "p", "", "password of the root user.")
// 	// configureCmd.Flags().StringVarP(&rootUser.ConfirmPassword, "confirm-password", "c", "", "confirmation prompt for the root user.")

// }

// var configureCmd = &cobra.Command{
// 	Use:   "configure",
// 	Short: "Configure Porichoy",
// 	Long:  `Configure Porichoy`,
// 	Run: func(cmd *cobra.Command, args []string) {
// 		rootUser := &RootUser{}
// 		rootApp := &RootApp{
// 			Name: "Porichoy",
// 		}
// 		utils.Welcome()
// 		promptRootUser(rootUser)
// 		promptRootApp(rootApp)
// 		protocol := "https://"
// 		if strings.Contains(rootApp.Domain, "local") {
// 			protocol = "http://"
// 		}
// 		rootApp.LandingUrl = protocol + rootApp.Domain + "/"
// 		rootApp.RedirectUris = []string{protocol + rootApp.Domain + "/authorize"}
// 		rootApp.SuccessCallbackUrl = protocol + rootApp.Domain + "/authorize"
// 		rootApp.ErrorCallbackUrl = protocol + rootApp.Domain + "/authorize/error"
// 		rootApp.JwtSecretResolver = rootApp.JwtSecretResolveFrom + "://" + rootApp.JwtSecretResolver
// 		fmt.Printf("%+v\n", rootApp)

// 		configurePayload := struct {
// 			RootUser RootUser `json:"root_user"`
// 			RootApp  RootApp  `json:"root_app"`
// 		}{
// 			RootUser: *rootUser,
// 			RootApp:  *rootApp,
// 		}

// 		payload, err := json.Marshal(configurePayload)
// 		if err != nil {
// 			fmt.Println("Error marshaling configure payload:", err)
// 			return
// 		}

// 		resp, err := http.Post("http://localhost:8080/api/v1/config/configure", "application/json", bytes.NewReader(payload))
// 		if err != nil {
// 			fmt.Println("Error posting configure payload:", err)
// 			return
// 		}
// 		defer resp.Body.Close()
// 		body, err := io.ReadAll(resp.Body)
// 		if err != nil {
// 			fmt.Println("Error reading configure response:", err)
// 			return
// 		}

// 		var response map[string]any
// 		if err := json.Unmarshal(body, &response); err != nil {
// 			fmt.Println("Error unmarshaling configure response:", err)
// 			return
// 		}
// 		fmt.Println(response["message"])
// 		if response["error"] != nil {
// 			for k, v := range (response["error"]).(map[string]any) {
// 				fmt.Printf("\t %s: %s\n", k, (v).(map[string]any)["message"])
// 			}
// 		}
// 	},
// }

// func promptRootUser(u *RootUser) error {
// 	qs := []*survey.Question{
// 		{
// 			Name: "Email",
// 			Prompt: &survey.Input{
// 				Message: "Root user email:",
// 			},
// 			Validate: survey.Required,
// 		},
// 		{
// 			Name: "Name",
// 			Prompt: &survey.Input{
// 				Message: "Root user name:",
// 			},
// 			Validate: survey.Required,
// 		},
// 		{
// 			Name: "Password",
// 			Prompt: &survey.Password{
// 				Message: "Password:",
// 			},
// 			Validate: survey.Required,
// 		},
// 		{
// 			Name: "ConfirmPassword",
// 			Prompt: &survey.Password{
// 				Message: "Confirm password:",
// 			},
// 			Validate: func(ans any) error {
// 				if ans != u.Password {
// 					return fmt.Errorf("passwords do not match")
// 				}
// 				return nil
// 			},
// 		},
// 	}

// 	return survey.Ask(qs, u)
// }
// func promptRootApp(a *RootApp) error {
// 	return survey.Ask([]*survey.Question{
// 		// {
// 		// 	Name: "Name",
// 		// 	Prompt: &survey.Input{
// 		// 		Message: "App name:",
// 		// 	},
// 		// 	Validate: survey.Required,
// 		// },
// 		{
// 			Name: "Domain",
// 			Prompt: &survey.Input{
// 				Message: "App domain:",
// 			},
// 			Validate: survey.Required,
// 		},
// 		// {
// 		// 	Name: "LandingUrl",
// 		// 	Prompt: &survey.Input{
// 		// 		Message: "Landing URL:",
// 		// 	},
// 		// 	Validate: survey.Required,
// 		// },
// 		// {
// 		// 	Name: "RedirectUris",
// 		// 	Prompt: &survey.Multiline{
// 		// 		Message: "Redirect URIs (one per line):",
// 		// 	},
// 		// 	Validate: survey.Required,
// 		// },
// 		{
// 			Name: "JwtAlgo",
// 			Prompt: &survey.Select{
// 				Options: []string{"HS256", "RS256", "JWKS"},
// 				Message: "Please select an option:",
// 			},
// 			Validate: survey.Required,
// 		},
// 		{
// 			Name: "JwtSecretResolveFrom",
// 			Prompt: &survey.Select{
// 				Options: []string{"env", "file", "literal"},
// 				Message: "Please select an option:",
// 			},
// 		},
// 		{
// 			Name: "JwtSecretResolver",
// 			Prompt: &survey.Input{
// 				Message: "Jwt resolver:",
// 			},
// 			Validate: survey.Required,
// 		},
// 		{
// 			Name: "JwtLifetime",
// 			Prompt: &survey.Input{
// 				Message: "JWT lifetime:",
// 			},
// 			Validate: survey.Required,
// 		},
// 		{
// 			Name: "RefreshTokenLifetime",
// 			Prompt: &survey.Input{
// 				Message: "Refresh token lifetime:",
// 			},
// 			Validate: survey.Required,
// 		},
// 	}, a)
// }
